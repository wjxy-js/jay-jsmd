<!DOCTYPE html>
<html>

<head>
	<meta charset="UTF-8">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0">
	<title>珠峰培训 - 微信：18310612838</title>
	<!-- IMPORT CSS -->
</head>

<body>
	<!-- IMPORT JS -->
	<script>
		/*
		 * 在JS中用单引号、双引号、反引号包起来的都是字符串：每一个字符串都是由零到多个字符组成的，和数组类似，每一个字符也都有自己的索引
		 *   索引0  ->  'w'
		 *   索引1  ->  'e'
		 * str.length存储了一共有多少个字符，也就是字符串的长度
		 */
		// let str = "welcome to zhufeng peixun！";
		// console.log(str[0]); //=>基于索引获取指定位置的字符
		// 遍历字符串中的每一个字符
		// for (let i = 0; i < str.length; i++) {
		// 	console.log(str[i]);
		// }

		/*
		 * 关于字符串中常用的方法
		 *   1.获取字符串中指定位置字符的办法
		 *     + charAt
		 *     + charCodeAt
		 *     + String.fromCharCode
		 *   2.字符串查找和截取
		 *     + substr
		 *     + substring
		 *     + slice
		 *   3.字符串转换为数组的方法
		 *     + split
		 *   4.字符串查找是否包含某个字符
		 *     + indexOf / lastIndexOf
		 *     + includes
		 *   5.字符串替换
		 *     + replace
		 *   6.字符串大小写转换
		 * 	   + toLowerCase
		 *     + toUpperCase
		 *   ....
		 *   localCompare / match / trim ... 
		 * 
		 * 记忆方式:
		 *   1）方法的意义和作用
		 *   2）参数
		 *   3）返回值
		 *   字符串中无需记忆原始字符串是否改变，因为它是基本类型值，每一个操作都是直接操作值，对原始字符串不会产生任何影响（数组之所以要记住是否改变，是因为数组是对象类型，操作的是堆内存，方法的执行很可能把原始堆内存中的信息改变了，所以需要记忆原始数组是否改变）
		 */
		// console.log(String.prototype);


		/*
		 * charAt([index])：根据索引获取指定位置的字符（charAt相对于直接基于索引获取的方式，在当前索引并不存在的情况下，字符串[索引]获取的结果是UNDEFINED，而CHARAT获取的结果是空字符串）
		 * charCodeAt：在charAt的基础上获取指定字符的UNICODE编码（ASCII码表中的值）
		 * String.fromCharCode([UNICODE编码])：和charCodeAt对应，它是基于编码获取编码前的字符
		 */
		// let str = "welcome to zhufeng peixun！";
		// console.log(str[0]); //=>'w'
		// console.log(str.charAt(0)); //=>'w'
		// console.log(str[str.length - 1]); //=>'！'
		// console.log(str.charAt(str.length - 1)); //=>'！'
		// console.log(str[str.length]); //=>undefined
		// console.log(str.charAt(str.length)); //=>'' 

		// console.log(str.charCodeAt(0)); //=>119 （UNICODE编码，也就是值的十进制编码）
		// console.log(String.fromCharCode(119)); //=>'w'

		/* 
		 * 字符串截取
		 *   substr(n,m)：从索引n开始截取m个字符
		 *   substring(n,m)：从索引n开始，找到索引为m处（不包含m），找到部分截取到
		 *   slice(n,m)：和substring是以一样的，两个都是索引，只不过slice支持以负数作为索引
		 * 
		 * 最后的m不写都是截取到字符串的末尾
		 */
		// let str = "welcome to zhufeng peixun！";
		// console.log(str.substr(3, 8)); //=>'come to '
		// console.log(str.substring(3, 8)); //=>come '
		// console.log(str.substring(3)); //=>substr&substring第二个参数不写都是截取到末尾  str.substring(0)：字符串克隆

		// console.log(str.substring(-6, -3)); //=>'' substring只能支持正常的索引
		// console.log(str.slice(-6, -
		// 3)); //=>'eix'  slice支持负数索引  负数索引也可以这样处理str.slice(str.length-6, str.length-3) => str.slice(20,23)


		/*
		 *  indexOf / lastIndexOf：获取当前字符在字符串中第一次或者最后一次出现位置的索引，如果字符串中不包含这个字符，返回结果是-1
		 *  includes 验证是否包含某个字符
		 */
		// let str = "welcome to zhufeng peixun！";
		// console.log(str.indexOf('e')); //=>1
		// console.log(str.lastIndexOf('e')); //=>20
		/* if (str.indexOf('a') > -1) {
			// 包含字符a
		} */
		/* if (str.includes('a')) {
			// 包含字符a
		} */

		/*
		 *  toLowerCase / toUpperCase：把字符串中的字符进行大小写转换
		 */
		// let str = 'Welcome To ZHUFENG!';
		// console.log(str.toLowerCase()); //=>'welcome to zhufeng!'
		// console.log(str.toUpperCase()); //=>'WELCOME TO ZHUFENG!'

		/*
		 *  split：和数组中的join方法对应，它是把字符串，按照指定的分隔符号，拆分成数组中的每一项，返回结果是一个数组
		 */
		// let arr = [10, 20, 30, 40];
		// let str = arr.join('|');
		// // console.log(str); //=>'10|20|30|40'
		// console.log(str.split('|')); //=>["10", "20", "30", "40"]

		// let str = "welcome to zhufeng peixun";
		// console.log(str.split(' ')); //=>以空格拆分  ["welcome", "to", "zhufeng", "peixun"]
		// console.log(str.split(
		// '')); //=>不指定任何分隔符 ["w", "e", "l", "c", "o", "m", "e", " ", "t", "o", " ", "z", "h", "u", "f", "e", "n", "g", " ", "p", "e", "i", "x", "u", "n"]

		// let str = '10|';
		// console.log(str.split('|')); //=>["10", ""]


		/*
		 * replace(原始字符,新字符)：把字符串中原始字符替换成为新字符，在不使用正则的情况下，每次执行replace只能替换一个
		 */
		// let str = 'zhufeng2020zhufeng2021';
		// str = str.replace('zhufeng', '珠峰');
		// str = str.replace('zhufeng', '珠峰');
		// console.log(str); //=>'珠峰2020珠峰2021'

		// str = str.replace('zhufeng', 'zhufengpeixun');
		// str = str.replace('zhufeng', 'zhufengpeixun');
		// console.log(str); //=>'zhufengpeixunpeixun2020zhufeng2021' 很多时候即使执行多次也不一定能够实现最后的效果，所以replace一般都是伴随正则出现的
		// str = str.replace(/zhufeng/g, 'zhufengpeixun');
		// console.log(str); //=>'zhufengpeixun2020zhufengpeixun2021'
	</script>
</body>

</html>